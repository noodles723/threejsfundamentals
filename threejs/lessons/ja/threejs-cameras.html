<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ja/threejs-cameras.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Three.jsでのカメラの使い方">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ja.jpg">

<meta property="og:title" content="Three.jsのカメラ">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ja.jpg">
<meta property="og:description" content="Three.jsでのカメラの使い方">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.jsのカメラ">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html">
<meta name="twitter:description" content="Three.jsでのカメラの使い方">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ja.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-cameras.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-cameras.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-cameras.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-cameras.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-cameras.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-cameras.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html",
      "inLanguage":"ja",
      "name":"Three.jsのカメラ",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-cameras.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.jsのカメラ</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-cameras.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-cameras.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-cameras.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-cameras.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-cameras.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-cameras.html" >中文</a>
</select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ja/">threejsfundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.jsのカメラ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>この記事はThree.jsの連載記事の1つです。
最初の記事は<a href="threejs-fundamentals.html">Three.jsの基礎知識</a>です。
まだ読んでいない場合、そこから始めると良いかもしれません。</p>
<p>three.jsでのカメラの話をしましょう。
<a href="threejs-fundamentals.html">最初の記事</a>でいくつか取り上げましたが、ここではもっと詳しく取り上げます。</p>
<p><code class="notranslate" translate="no">PerspectiveCamera（透視投影カメラ）</code> はthree.jsで最も一般的なカメラで、今までの記事で使ってきました。
遠くのものが近くのものよりも小さく見える3Dビューを提供します。</p>
<p><code class="notranslate" translate="no">PerspectiveCamera</code> は <em>錐台</em> を定義します。
<a href="https://en.wikipedia.org/wiki/Frustum">錐台とは先端が切り取られたピラミッドのような3D形状の事です</a>。
つまり、cube(立方体)、cone(円錐体)、sphere(球体)、cylinder(円柱)、frustum(錐台)は全て異なる種類の固体名です。</p>
<div class="spread">
  <div><div data-diagram="shapeCube"></div><div>cube</div></div>
  <div><div data-diagram="shapeCone"></div><div>cone</div></div>
  <div><div data-diagram="shapeSphere"></div><div>sphere</div></div>
  <div><div data-diagram="shapeCylinder"></div><div>cylinder</div></div>
  <div><div data-diagram="shapeFrustum"></div><div>frustum</div></div>
</div>

<p>私はこの事を何年も知らなかったです。
どこかの本やページで <em>錐台</em> について書かれていると目が点になります。
錐台が固体名と理解すると、それらの記述を急に理解できるようになりました &#128517;</p>
<p><code class="notranslate" translate="no">PerspectiveCamera</code> には4つのプロパティをもとに錐台が定義されています。
<code class="notranslate" translate="no">near</code> は錐台の正面がどこから始まるかを定義します。
<code class="notranslate" translate="no">far</code> は錐台が終了する場所です。
<code class="notranslate" translate="no">fov</code> は視野角で、カメラから <code class="notranslate" translate="no">near</code> 単位で指定された視野角を得るために正しい高さが計算され、錐台の前面と背面の高さを定義します。
<code class="notranslate" translate="no">aspect</code> は錐台の前面と背面の幅です。
錐台の幅は高さにaspectを掛けたものです。</p>
<p><img src="../resources/frustum-3d.svg" width="500" class="threejs_center"/></p>
<p><a href="threejs-lights.html">前回の記事</a>から地面となる平面、球体、立方体のあるシーンを利用し、カメラの設定を調整してみましょう。</p>
<p><code class="notranslate" translate="no">near</code> と <code class="notranslate" translate="no">far</code> の設定用に <code class="notranslate" translate="no">MinMaxGUIHelper</code> を作成します。
<code class="notranslate" translate="no">far</code> が常に <code class="notranslate" translate="no">near</code> よりも大きい値になるようにします。
MinMaxGUIHelperは <code class="notranslate" translate="no">min</code> と <code class="notranslate" translate="no">max</code> のプロパティがあり、dat.GUIで調整します。
GUIで値を調整すると2つのプロパティに設定されます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class MinMaxGUIHelper {
  constructor(obj, minProp, maxProp, minDif) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
    this.minDif = minDif;
  }
  get min() {
    return this.obj[this.minProp];
  }
  set min(v) {
    this.obj[this.minProp] = v;
    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
  }
  get max() {
    return this.obj[this.maxProp];
  }
  set max(v) {
    this.obj[this.maxProp] = v;
    this.min = this.min;  // this will call the min setter
  }
}
</code></pre>
<p>これでGUIを以下のように設定できます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function updateCamera() {
  camera.updateProjectionMatrix();
}

const gui = new GUI();
gui.add(camera, &#39;fov&#39;, 1, 180).onChange(updateCamera);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, &#39;near&#39;, &#39;far&#39;, 0.1);
gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
</code></pre>
<p>カメラ設定の変更時、カメラの <a href="PerspectiveCamera.updateProjectionMatrix"><code class="notranslate" translate="no">updateProjectionMatrix</code></a> 関数を呼び出す必要があります。
<code class="notranslate" translate="no">updateCamera</code> という関数を作り、それをdat.GUI変更時に呼び出すようにします。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-perspective.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-perspective.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>値を調整すると動作が確認できます。
<code class="notranslate" translate="no">aspect</code> を調整したい場合は、新しいウィンドウでサンプルを開いてからウィンドウサイズを変更して下さい。</p>
<p>それでもまだ少し見づらいので、2つのカメラを持つサンプルに変えます。
1つ目のカメラは上記で見たシーンを表示し、2つ目のカメラは1つ目のカメラが描画してるシーンを見ている別のカメラとし、そのカメラの錐台を表示します。</p>
<p>そのためにthree.jsのシザー関数を利用します。
シザー機能を使い、カメラを2台並べて2つのシーンを描画するように変更してみましょう。</p>
<p>まず、HTMLとCSSを使って2つの並んでるDOM要素を定義してみましょう。
両方のカメラが簡単に独自の <code class="notranslate" translate="no">OrbitControls</code> を持てるようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
+  &lt;div class=&quot;split&quot;&gt;
+     &lt;div id=&quot;view1&quot; tabindex=&quot;1&quot;&gt;&lt;/div&gt;
+     &lt;div id=&quot;view2&quot; tabindex=&quot;2&quot;&gt;&lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>このview1とview2をキャンバスの上に重ねて表示させます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">.split {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
}
.split&gt;div {
  width: 100%;
  height: 100%;
}
</code></pre>
<p>次に <code class="notranslate" translate="no">CameraHelper</code> を追加します。
<code class="notranslate" translate="no">CameraHelper</code> は <code class="notranslate" translate="no">Camera</code> の錐台を描画します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const cameraHelper = new THREE.CameraHelper(camera);

...

scene.add(cameraHelper);
</code></pre>
<p>view1とview2のDOM要素をquerySelectorしましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const view1Elem = document.querySelector(&#39;#view1&#39;);
const view2Elem = document.querySelector(&#39;#view2&#39;);
</code></pre>
<p>既存の <code class="notranslate" translate="no">OrbitControls</code> をview1にのみ反応するようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const controls = new OrbitControls(camera, canvas);
+const controls = new OrbitControls(camera, view1Elem);
</code></pre>
<p>2つ目の <code class="notranslate" translate="no">PerspectiveCamera</code> と <code class="notranslate" translate="no">OrbitControls</code> を作ってみましょう。
2つ目の <code class="notranslate" translate="no">OrbitControls</code> は2つ目のカメラに関連付けし、view2から入力を取得します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const camera2 = new THREE.PerspectiveCamera(
  60,  // fov
  2,   // aspect
  0.1, // near
  500, // far
);
camera2.position.set(40, 10, 30);
camera2.lookAt(0, 5, 0);

const controls2 = new OrbitControls(camera2, view2Elem);
controls2.target.set(0, 5, 0);
controls2.update();
</code></pre>
<p>最後にキャンバスの一部だけをレンダリングするために、シザー機能を使い各カメラの視点からシーンをレンダリングします。</p>
<p>ここにDOM要素を渡すと、キャンバスに重なる矩形を計算する関数があります。
その矩形にシザーとビューポートを設定し、アスペクト比を返します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setScissorForElement(elem) {
  const canvasRect = canvas.getBoundingClientRect();
  const elemRect = elem.getBoundingClientRect();

  // compute a canvas relative rectangle
  const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
  const left = Math.max(0, elemRect.left - canvasRect.left);
  const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
  const top = Math.max(0, elemRect.top - canvasRect.top);

  const width = Math.min(canvasRect.width, right - left);
  const height = Math.min(canvasRect.height, bottom - top);

  // setup the scissor to only render to that part of the canvas
  const positiveYUpBottom = canvasRect.height - bottom;
  renderer.setScissor(left, positiveYUpBottom, width, height);
  renderer.setViewport(left, positiveYUpBottom, width, height);

  // return the aspect
  return width / height;
}
</code></pre>
<p>この関数を使って <code class="notranslate" translate="no">render</code> 関数でシーンを2回描画できます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  function render() {

-    if (resizeRendererToDisplaySize(renderer)) {
-      const canvas = renderer.domElement;
-      camera.aspect = canvas.clientWidth / canvas.clientHeight;
-      camera.updateProjectionMatrix();
-    }

+    resizeRendererToDisplaySize(renderer);
+
+    // turn on the scissor
+    renderer.setScissorTest(true);
+
+    // render the original view
+    {
+      const aspect = setScissorForElement(view1Elem);
+
+      // adjust the camera for this aspect
+      camera.aspect = aspect;
+      camera.updateProjectionMatrix();
+      cameraHelper.update();
+
+      // don&#39;t draw the camera helper in the original view
+      cameraHelper.visible = false;
+
+      scene.background.set(0x000000);
+
+      // render
+      renderer.render(scene, camera);
+    }
+
+    // render from the 2nd camera
+    {
+      const aspect = setScissorForElement(view2Elem);
+
+      // adjust the camera for this aspect
+      camera2.aspect = aspect;
+      camera2.updateProjectionMatrix();
+
+      // draw the camera helper in the 2nd view
+      cameraHelper.visible = true;
+
+      scene.background.set(0x000040);
+
+      renderer.render(scene, camera2);
+    }

-    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}
</code></pre>
<p>上記のコードはview1とview2を区別するために、view2をレンダリング時のシーンの背景色を紺色にしています。</p>
<p>また、<code class="notranslate" translate="no">render</code> 関数内で全て更新しているため、<code class="notranslate" translate="no">updateCamera</code> のコードを削除できます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function updateCamera() {
-  camera.updateProjectionMatrix();
-}

const gui = new GUI();
-gui.add(camera, &#39;fov&#39;, 1, 180).onChange(updateCamera);
+gui.add(camera, &#39;fov&#39;, 1, 180);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, &#39;near&#39;, &#39;far&#39;, 0.1);
-gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
-gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
+gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;);
+gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;);
</code></pre>
<p>片方のviewを使い、もう片方の錐台を見るれるようになりました。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-perspective-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-perspective-2-scenes.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>左側はオリジナルのビュー、右側はカメラの錐台を表示するビューがあります。
マウスで <code class="notranslate" translate="no">near</code>、<code class="notranslate" translate="no">far</code>、<code class="notranslate" translate="no">fov</code> を調整してカメラを動かすと、右側に表示されている錐台の内側だけが左側のシーンに表示されています。</p>
<p><code class="notranslate" translate="no">near</code> を20くらいに調整すると、錐台に入らずオブジェクトの正面が消えます。
<code class="notranslate" translate="no">far</code> を35以下に調整すると、錐台に入らず地上の平面が消えていきます。</p>
<p>ここで疑問が湧いてきました。
<code class="notranslate" translate="no">near</code> を0.0000000001に <code class="notranslate" translate="no">far</code> を10000000000000に設定し、全てを見えるようにできないでしょうか？
なぜなら、GPUは何かが前後にあるかを判断する精度が高いからです。
その精度は <code class="notranslate" translate="no">near</code> と <code class="notranslate" translate="no">far</code> の間に分散しています。
さらに悪い事にデフォルトではカメラの近くの精度は細かく、カメラから遠い精度は粗くなっています。
単位の値は <code class="notranslate" translate="no">near</code> から始まり、<code class="notranslate" translate="no">far</code> に近づくにつれて徐々に拡大していきます。</p>
<p>上記のサンプルから始めて、20個の球体を1列に挿入するコードに変更してみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
  const numSpheres = 20;
  for (let i = 0; i &lt; numSpheres; ++i) {
    const sphereMat = new THREE.MeshPhongMaterial();
    sphereMat.color.setHSL(i * .73, 1, 0.5);
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    mesh.position.set(-sphereRadius - 1, sphereRadius + 2, i * sphereRadius * -2.2);
    scene.add(mesh);
  }
}
</code></pre>
<p><code class="notranslate" translate="no">near</code> を0.00001に設定してみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fov = 45;
const aspect = 2;  // the canvas default
-const near = 0.1;
+const near = 0.00001;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
</code></pre>
<p>値の編集時に0.00001を許容するようにGUIコードを微調整します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
+gui.add(minMaxGUIHelper, &#39;min&#39;, 0.00001, 50, 0.00001).name(&#39;near&#39;).onChange(updateCamera);
</code></pre>
<p>何が起こると思いますか？</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-z-fighting.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-z-fighting.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>これはGPUがどのピクセルが前後にあるか判断する精度が不足してる時に <em>Zファイティング</em> が発生する例です。</p>
<p>あなたのマシンでは問題が表示されない可能性がありますが、私のマシンでは以下のように表示されます。</p>
<div class="threejs_center"><img src="../resources/images/z-fighting.png" style="width: 570px;"></div>

<p>1つ目の解決策はどのピクセルが前後にあるかを計算するために、three.jsの別メソッドを使用します。
これは <code class="notranslate" translate="no">WebGLRenderer</code> の作成時に <code class="notranslate" translate="no">logarithmicDepthBuffer</code> を有効にします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const renderer = new THREE.WebGLRenderer({canvas});
+const renderer = new THREE.WebGLRenderer({
+  canvas,
+  logarithmicDepthBuffer: true,
+});
</code></pre>
<p>これで上手く動くかもしれません。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-logarithmic-depth-buffer.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-logarithmic-depth-buffer.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>これで問題が解決しない場合、この解決策が使えない理由の1つに遭遇した事になります。
その理由は、特定のGPUのみをサポートしているためです。
2018年9月現在、ほとんどのデスクトップがこの解決策をサポートしていますが、モバイルデバイスはほとんどサポートしていません。</p>
<p>この解決策を選択しないもう1つの理由は、標準的な解決策よりも大幅に遅くなる可能性があります。</p>
<p>この解決策は解像度に制限があります。
<code class="notranslate" translate="no">near</code> をさらに小さくしたり <code class="notranslate" translate="no">far</code> をさらに大きくしたりすると最終的に同じ問題にぶつかります。</p>
<p><code class="notranslate" translate="no">near</code> と <code class="notranslate" translate="no">far</code> の設定は、常にユースケースに合った値を選択して下さい。
<code class="notranslate" translate="no">near</code> はカメラからできるだけ離れた所に置き、オブジェクトが消えないようにしましょう。
<code class="notranslate" translate="no">far</code> はカメラからできるだけ近い所に置き、オブジェクトが消えないようにしましょう。</p>
<p>もしまつげを見れるぐらい誰かの顔をクローズアップし、背景には50キロ離れた山までの道のりを見る巨大なシーンを描画したい場合、他の創造的な解決策を見つける必要があるでしょう。
この解決策は後にしましょう。
とりあえず自分のニーズに合わせて <code class="notranslate" translate="no">near</code> と <code class="notranslate" translate="no">far</code> は適切な値を選択しましょう。</p>
<p>2番目に一般的なカメラは <code class="notranslate" translate="no">OrthographicCamera(平行投影カメラ)</code> です。
錐台を指定するのではなく、<code class="notranslate" translate="no">left</code>、<code class="notranslate" translate="no">right</code>、<code class="notranslate" translate="no">top</code>、<code class="notranslate" translate="no">bottom</code>、<code class="notranslate" translate="no">near</code>、<code class="notranslate" translate="no">far</code> の設定でボックスを指定します。
ボックスを投影しているので遠近感はありません。</p>
<p>上記のview1とview2のサンプルを変更し、最初のビューで <code class="notranslate" translate="no">OrthographicCamera</code> を使うようにしましょう。</p>
<p>最初に <code class="notranslate" translate="no">OrthographicCamera</code> を設定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const left = -1;
const right = 1;
const top = 1;
const bottom = -1;
const near = 5;
const far = 50;
const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
camera.zoom = 0.2;
</code></pre>
<p><code class="notranslate" translate="no">left</code> と <code class="notranslate" translate="no">bottom</code> を-1、<code class="notranslate" translate="no">right</code> と <code class="notranslate" translate="no">top</code> を1にしました。
これで箱の幅が2、高さが2になりますが、描画している矩形のアスペクト比で <code class="notranslate" translate="no">left</code> と <code class="notranslate" translate="no">top</code> を調整します。
<code class="notranslate" translate="no">zoom</code> プロパティでカメラで実際に表示される値を簡単に調整できます。</p>
<p>GUIに <code class="notranslate" translate="no">zoom</code> の設定を追加してみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
+gui.add(camera, &#39;zoom&#39;, 0.01, 1, 0.01).listen();
</code></pre>
<p><code class="notranslate" translate="no">listen</code> 呼び出しはdat.GUIに変更を監視するようにします。
これは <code class="notranslate" translate="no">OrbitControls</code> がズームも制御できるからです。
例えばマウスのスクロールホイールは <code class="notranslate" translate="no">OrbitControls</code> でズームします。</p>
<p>最後に左側をレンダリングする部分を変更して <code class="notranslate" translate="no">OrthographicCamera</code> を更新します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const aspect = setScissorForElement(view1Elem);

  // update the camera for this aspect
-  camera.aspect = aspect;
+  camera.left   = -aspect;
+  camera.right  =  aspect;
  camera.updateProjectionMatrix();
  cameraHelper.update();

  // don&#39;t draw the camera helper in the original view
  cameraHelper.visible = false;

  scene.background.set(0x000000);
  renderer.render(scene, camera);
}
</code></pre>
<p>これで <code class="notranslate" translate="no">OrthographicCamera</code> が動作しているのが見れるようになりました。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-orthographic-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-orthographic-2-scenes.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>three.jsで2次元のものを描画する場合には、<code class="notranslate" translate="no">OrthographicCamera</code> が最もよく使われます。
カメラの表示台数を決める必要があります。
例えば、1ピクセルのキャンバスをカメラの1単位と一致させたい場合、次のような事ができます。</p>
<p>原点を中心に置き、1ピクセル = three.jsの1単位とするには次のようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">camera.left = -canvas.width / 2;
camera.right = canvas.width / 2;
camera.top = canvas.height / 2;
camera.bottom = -canvas.height / 2;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
</code></pre>
<p>原点を2Dキャンバスのように左上に配置したい場合は、次のようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">camera.left = 0;
camera.right = canvas.width;
camera.top = 0;
camera.bottom = canvas.height;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
</code></pre>
<p>この場合、左上の角は2Dキャンバスのように0, 0になります。</p>
<p>やってみましょう！まずはカメラの設定をします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const left = 0;
const right = 300;  // default canvas size
const top = 0;
const bottom = 150;  // default canvas size
const near = -1;
const far = 1;
const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
camera.zoom = 1;
</code></pre>
<p>続いて、6枚のテクスチャをロードし、6枚の平面を作ってみましょう。
各平面は <code class="notranslate" translate="no">THREE.Object3D</code> を親にし、平面の中心を左上にして簡単にオフセットできるようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const loader = new THREE.TextureLoader();
const textures = [
  loader.load(&#39;resources/images/flower-1.jpg&#39;),
  loader.load(&#39;resources/images/flower-2.jpg&#39;),
  loader.load(&#39;resources/images/flower-3.jpg&#39;),
  loader.load(&#39;resources/images/flower-4.jpg&#39;),
  loader.load(&#39;resources/images/flower-5.jpg&#39;),
  loader.load(&#39;resources/images/flower-6.jpg&#39;),
];
const planeSize = 256;
const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
const planes = textures.map((texture) =&gt; {
  const planePivot = new THREE.Object3D();
  scene.add(planePivot);
  texture.magFilter = THREE.NearestFilter;
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  planePivot.add(mesh);
  // move plane so top left corner is origin
  mesh.position.set(planeSize / 2, planeSize / 2, 0);
  return planePivot;
});
</code></pre>
<p>キャンバスサイズの変更時、カメラを更新する必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render() {

  if (resizeRendererToDisplaySize(renderer)) {
    camera.right = canvas.width;
    camera.bottom = canvas.height;
    camera.updateProjectionMatrix();
  }

  ...
</code></pre>
<p><code class="notranslate" translate="no">planes</code> は <code class="notranslate" translate="no">THREE.Mesh</code> の配列であり、各平面に1つずつあります。
これらを時間に応じて移動させてみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;  // convert to seconds;

  ...

  const distAcross = Math.max(20, canvas.width - planeSize);
  const distDown = Math.max(20, canvas.height - planeSize);

  // total distance to move across and back
  const xRange = distAcross * 2;
  const yRange = distDown * 2;
  const speed = 180;

  planes.forEach((plane, ndx) =&gt; {
    // compute a unique time for each plane
    const t = time * speed + ndx * 300;

    // get a value between 0 and range
    const xt = t % xRange;
    const yt = t % yRange;

    // set our position going forward if 0 to half of range
    // and backward if half of range to range
    const x = xt &lt; distAcross ? xt : xRange - xt;
    const y = yt &lt; distDown   ? yt : yRange - yt;

    plane.position.set(x, y, 0);
  });

  renderer.render(scene, camera);
</code></pre>
<p>2Dキャンバスのようにピクセル計算を使い、画像がキャンバスの縁からピクセルのように跳ね返っているのが分かります。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-orthographic-canvas-top-left-origin.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-orthographic-canvas-top-left-origin.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p><code class="notranslate" translate="no">OrthographicCamera</code> のもう1つの一般的な用途は3Dモデリングツールやゲームエンジンで、上、下、左、右、正面、背面のビューを描画する場合です。</p>
<div class="threejs_center"><img src="../resources/images/quad-viewport.png" style="width: 574px;"></div>

<p>上記のスクリーンショットでは右上のビューが透視投影図、左上のビューが平行投影図です。</p>
<p>それがカメラの基本です。
カメラを動かすための一般的な方法は別の記事で紹介します。
とりあえず<a href="threejs-shadows.html">影</a>についてのページに移りましょう。</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-cameras.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-cameras.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-cameras.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-cameras.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-cameras.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-cameras.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-cameras.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-fundamentals.html">基礎知識</a></li>
<li><a href="/threejs/lessons/ja/threejs-responsive.html">レスポンシブデザイン</a></li>
<li><a href="/threejs/lessons/ja/threejs-prerequisites.html">前提条件</a></li>
<li><a href="/threejs/lessons/ja/threejs-setup.html">セットアップ</a></li>
        </ul>
  <li>基礎</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-primitives.html">プリミティブ</a></li>
<li><a href="/threejs/lessons/ja/threejs-scenegraph.html">シーングラフ</a></li>
<li><a href="/threejs/lessons/ja/threejs-materials.html">マテリアル</a></li>
<li><a href="/threejs/lessons/ja/threejs-textures.html">テクスチャ</a></li>
<li><a href="/threejs/lessons/ja/threejs-lights.html">ライト</a></li>
<li><a href="/threejs/lessons/ja/threejs-cameras.html">カメラ</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadows.html">Shadows</a></li>
<li><a href="/threejs/lessons/ja/threejs-fog.html">Fog</a></li>
<li><a href="/threejs/lessons/ja/threejs-rendertargets.html">Render Targets</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-geometry.html">Custom Geometry</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-buffergeometry.html">Custom BufferGeometry</a></li>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-rendering-on-demand.html">要求されたレンダリング</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-javascript.html">JavaScriptのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-glsl.html">GLSLのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#screenshot">スクリーンショットを撮る</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#preservedrawingbuffer">キャンバスがクリアされるのを防ぐ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#tabindex">キャンバスからキーボード入力を取得する</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#transparent-canvas">キャンバスを透明にする</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#html-background">HTMLの背景にthree.jsを使う</a></li>
        </ul>
  <li>最適化</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects.html">多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html">アニメーションする多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-offscreencanvas.html">Web WorkerでOffscreenCanvasを使用する</a></li>
        </ul>
  <li>解決策</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-load-obj.html">OBJファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-load-gltf.html">GLTFファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-backgrounds.html">背景やスカイボックスを追加する</a></li>
<li><a href="/threejs/lessons/ja/threejs-transparency.html">透明なオブジェクトの描画方法</a></li>
<li><a href="/threejs/lessons/ja/threejs-multiple-scenes.html">複数キャンバスと複数シーン</a></li>
<li><a href="/threejs/lessons/ja/threejs-picking.html">マウスでオブジェクトをピッキング</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing.html">ポストプロセス</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing-3dlut.html">エフェクトにLUTファイルを適用する</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ja/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ja/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ja/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ja/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ja/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ja/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ja/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>参照</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-material-table.html">Material Table</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.jsドキュメント</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>質問はありますか? <a href="http://stackoverflow.com/questions/tagged/three.js">何かあればstackoverflowで尋ねて下さい</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/threefundamentals/issues">またはgithubでissueを作って下さい</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.jsのカメラ';
            var disqus_title = 'Three.jsのカメラ';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "threejsfundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



