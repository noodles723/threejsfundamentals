<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ja/threejs-offscreencanvas.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="three.jsでweb workerを使う方法">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-offscreencanvas_ja.jpg">

<meta property="og:title" content="Three.jsのOffscreenCanvas">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-offscreencanvas_ja.jpg">
<meta property="og:description" content="three.jsでweb workerを使う方法">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.jsのOffscreenCanvas">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html">
<meta name="twitter:description" content="three.jsでweb workerを使う方法">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-offscreencanvas_ja.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-offscreencanvas.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-offscreencanvas.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-offscreencanvas.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-offscreencanvas.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-offscreencanvas.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-offscreencanvas_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html",
      "inLanguage":"ja",
      "name":"Three.jsのOffscreenCanvas",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-offscreencanvas.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.jsのOffscreenCanvas</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-offscreencanvas.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-offscreencanvas.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-offscreencanvas.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-offscreencanvas.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-offscreencanvas.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-offscreencanvas.html" >中文</a>
</select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ja/">threejsfundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.jsのOffscreenCanvas</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas"><code class="notranslate" translate="no">OffscreenCanvas</code></a>は新しいブラウザの機能で現在はChromeでしか利用できませんが、他のブラウザにも来るようです。
<code class="notranslate" translate="no">OffscreenCanvas</code> はWeb Workerでキャンバスにレンダリングできます。
複雑な3Dシーンのレンダリングなど重い作業をWeb Workerで行い負荷を軽減させ、ブラウザのレスポンスを低下させない方法です。
また、データが読み込まれWorkerで解析されてるのでページ読み込み中にページ表示の途切れは少ないでしょう。</p>
<p>OffscreenCanvasの利用を<em>開始</em>するのは非常に簡単です。
<a href="threejs-responsive.html">レスポンシブデザインの記事</a>から3つのキューブを回転させるコードに修正してみましょう。</p>
<p>通常はWorkerのコードを別ファイルに分離しますが、このサイトのほとんどのサンプルコードではスクリプトをHTMLファイルに埋め込んでいます。</p>
<p>ここでは <code class="notranslate" translate="no">offscreencanvas-cubes.js</code> というファイルを作成し、<a href="threejs-responsive.html">レスポンシブデザインの例</a>から全てのJavaScriptをコピーして下さい。
そして、Workerで実行するために必要な変更を行います。</p>
<p>HTMLファイルにはJavaScriptのいくつかの処理が必要です。
まず最初に行う必要があるのはキャンバスを検索し、<code class="notranslate" translate="no">canvas.transferControlToOffscreen</code> 呼び出してキャンバスのコントロールをオフスクリーンに転送します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
  const offscreen = canvas.transferControlToOffscreen();

  ...
</code></pre>
<p><code class="notranslate" translate="no">new Worker(pathToScript, {type: &#39;module&#39;})</code>でWorkerを起動し、<code class="notranslate" translate="no">offscreen</code> オブジェクトを渡します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
  const offscreen = canvas.transferControlToOffscreen();
  const worker = new Worker(&#39;offscreencanvas-cubes.js&#39;, {type: &#39;module&#39;});
  worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);
}
main();
</code></pre>
<p>ここで重要なのはWorkerが <code class="notranslate" translate="no">DOM</code> にアクセスできない事です。
HTML要素の参照やマウスイベントやキーボードイベントを受け取る事もできません。
Workerは、送られたメッセージに返信してWebページにメッセージを送り返す事だけです。</p>
<p>Workerにメッセージを送信するには<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage"><code class="notranslate" translate="no">worker.postMessage</code></a>を呼び出し、1つまたは2つの引数を渡します。
1つ目の引数は<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">クローン</a>されるJavaScriptオブジェクトでWorkerに送ります。
2番目の引数は任意でWorkerに <em>転送</em> したい最初のオブジェクトです。
このオブジェクトはクローンされません。
その代わりに <em>転送</em> され、メインページには存在しなくなります。
存在しなくなるというのはおそらく間違った説明であり、むしろ取り除かれます。
クローンではなく、特定のタイプのオブジェクトのみを転送する事ができます。
転送するオブジェクトには <code class="notranslate" translate="no">OffscreenCanvas</code> が含まれているので、1度転送した <code class="notranslate" translate="no">offscreen</code> オブジェクトをメインページに戻しても意味がありません。</p>
<p>Workerは <code class="notranslate" translate="no">onmessage</code> ハンドラからメッセージを受け取ります。
<code class="notranslate" translate="no">postMessage</code> に渡したオブジェクトはWorkerの <code class="notranslate" translate="no">onmessage</code> ハンドラに渡され <code class="notranslate" translate="no">event.data</code> を更新します。
上記のコードではWorkerに渡すオブジェクトに <code class="notranslate" translate="no">type: &#39;main&#39;</code> を宣言しています。
このオブジェクトはブラウザには何の意味もありません。Workerで使うためだけのものです。
<code class="notranslate" translate="no">type</code> に基づいて、Worker内で別の関数を呼び出すハンドラを作成します。
あとは必要に応じて関数を追加し、メインページから簡単に呼び出す事ができます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const handlers = {
  main,
};

self.onmessage = function(e) {
  const fn = handlers[e.data.type];
  if (!fn) {
    throw new Error(&#39;no handler for type: &#39; + e.data.type);
  }
  fn(e.data);
};
</code></pre>
<p>上記コードのように <code class="notranslate" translate="no">type</code> に基づいてハンドラを検索し、メインページから送られてきた <code class="notranslate" translate="no">data</code> を渡します。
あとは<a href="threejs-responsive.html">レスポンシブデザインの記事</a>から <code class="notranslate" translate="no">offscreencanvas-cubes.js</code> に貼り付けた <code class="notranslate" translate="no">main</code> を変更するだけです。</p>
<p>DOMからキャンバスを探すのではなく、イベントデータからキャンバスを受け取ります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function main() {
-  const canvas = document.querySelector(&#39;#c&#39;);
+function main(data) {
+  const {canvas} = data;
  const renderer = new THREE.WebGLRenderer({canvas});

  ...
</code></pre>
<p>最初の問題はWorkerからDOMを参照できず、<code class="notranslate" translate="no">resizeRendererToDisplaySize</code> が <code class="notranslate" translate="no">canvas.clientWidth</code> と <code class="notranslate" translate="no">canvas.clientHeight</code> を参照できない事です。
<code class="notranslate" translate="no">clientWidth</code> と <code class="notranslate" translate="no">canvas.clientHeight</code> はDOMの値です。</p>
<p>元のコードは以下の通りです。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
</code></pre>
<p>DOMを参照できないため、変更したサイズの値をWorkerに送る必要があります。
そこでグローバルな状態を追加し、幅と高さを維持するようにしましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const state = {
  width: 300,  // canvas default
  height: 150,  // canvas default
};
</code></pre>
<p>これらの値を更新するための <code class="notranslate" translate="no">&#39;size&#39;</code> ハンドラを追加してみます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function size(data) {
+  state.width = data.width;
+  state.height = data.height;
+}

const handlers = {
  main,
+  size,
};
</code></pre>
<p>これで <code class="notranslate" translate="no">resizeRendererToDisplaySize</code> を変更すると <code class="notranslate" translate="no">state.width</code> と <code class="notranslate" translate="no">state.height</code> が使えるようになりました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
-  const width = canvas.clientWidth;
-  const height = canvas.clientHeight;
+  const width = state.width;
+  const height = state.height;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
</code></pre>
<p>以下も同様の変更が必要です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;

  if (resizeRendererToDisplaySize(renderer)) {
-    camera.aspect = canvas.clientWidth / canvas.clientHeight;
+    camera.aspect = state.width / state.height;
    camera.updateProjectionMatrix();
  }

  ...
</code></pre>
<p>メインページに戻りページのリサイズの度に <code class="notranslate" translate="no">size</code> イベントを送信します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const worker = new Worker(&#39;offscreencanvas-picking.js&#39;, {type: &#39;module&#39;});
worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);

+function sendSize() {
+  worker.postMessage({
+    type: &#39;size&#39;,
+    width: canvas.clientWidth,
+    height: canvas.clientHeight,
+  });
+}
+
+window.addEventListener(&#39;resize&#39;, sendSize);
+sendSize();
</code></pre>
<p>初期サイズを送るために1度sendSizeを呼んでいます。</p>
<p>ブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> を完全にサポートしていると仮定して、これらの変更を行うだけで動作するはずです。
実行する前にブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> を実際にサポートしているか確認し、サポートしていない場合はエラーを表示してみましょう。
まずはエラーを表示するためのHTMLを追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
+  &lt;div id=&quot;noOffscreenCanvas&quot; style=&quot;display:none;&quot;&gt;
+    &lt;div&gt;no OffscreenCanvas support&lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>そして、CSSを追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">#noOffscreenCanvas {
    display: flex;
    width: 100vw;
    height: 100vh;
    align-items: center;
    justify-content: center;
    background: red;
    color: white;
}
</code></pre>
<p>ブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> をサポートしているか確認するためには <code class="notranslate" translate="no">transferControlToOffscreen</code> を呼びます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
+  if (!canvas.transferControlToOffscreen) {
+    canvas.style.display = &#39;none&#39;;
+    document.querySelector(&#39;#noOffscreenCanvas&#39;).style.display = &#39;&#39;;
+    return;
+  }
  const offscreen = canvas.transferControlToOffscreen();
  const worker = new Worker(&#39;offscreencanvas-picking.js&#39;, {type: &#39;module});
  worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);

  ...
</code></pre>
<p>ブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> をサポートしていれば、このサンプルは動作するはずです。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-offscreencanvas.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-offscreencanvas.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>これは素晴らしい事ですが、今の所は全てのブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> をサポートしている訳ではなく、
<code class="notranslate" translate="no">OffscreenCanvas</code> サポートありとサポートなしの両方で動作するコードに変更し、サポートなしの場合はメインページのキャンバスを通常のように表示します。</p>
<blockquote>
<p>余談ですがページをレスポンシブにするためにOffscreenCanvasが必要な場合、フォールバックを持つ意味がよくわかりません。
メインページで実行するかWorkerで実行するかには、Workerで実行している時にメインページで実行している時よりも多くの事ができるように
調整するかもしれません。何をするかは本当にあなた次第です。</p>
</blockquote>
<p>まず最初にthree.jsのコードとWorkerの固有コードを分離しましょう。
これでメインページとWorkerの両方で同じコードを使う事ができます。
つまり、3つのファイルを持つ事になります。</p>
<ol>
<li><p>htmlファイル</p>
<p><code class="notranslate" translate="no">threejs-offscreencanvas-w-fallback.html</code></p>
</li>
<li><p>three.jsを含むJavaScriptコード</p>
<p><code class="notranslate" translate="no">shared-cubes.js</code></p>
</li>
<li><p>workerをサポートするコード</p>
<p><code class="notranslate" translate="no">offscreencanvas-worker-cubes.js</code></p>
</li>
</ol>
<p><code class="notranslate" translate="no">shared-cubes.js</code> と <code class="notranslate" translate="no">offscreencanvas-worker-cubes.js</code> は前の <code class="notranslate" translate="no">offscreencanvas-cubes.js</code> ファイルを分割したものです。</p>
<p>まず <code class="notranslate" translate="no">offscreencanvas-cubes.js</code> を全て <code class="notranslate" translate="no">shared-cube.js</code> にコピーします。
次にHTMLファイルには既に <code class="notranslate" translate="no">main</code> があり、<code class="notranslate" translate="no">init</code> と <code class="notranslate" translate="no">state</code> をエクスポートする必要があるため <code class="notranslate" translate="no">main</code> の名前を <code class="notranslate" translate="no">init</code> に変更します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import * as THREE from &#39;./resources/threejs/r122/build/three.module.js&#39;;

-const state = {
+export const state = {
  width: 300,   // canvas default
  height: 150,  // canvas default
};

-function main(data) {
+export function init(data) {
  const {canvas} = data;
  const renderer = new THREE.WebGLRenderer({canvas});
</code></pre>
<p>そして、three.js関連以外の部分だけを切り取ります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function size(data) {
-  state.width = data.width;
-  state.height = data.height;
-}
-
-const handlers = {
-  main,
-  size,
-};
-
-self.onmessage = function(e) {
-  const fn = handlers[e.data.type];
-  if (!fn) {
-    throw new Error(&#39;no handler for type: &#39; + e.data.type);
-  }
-  fn(e.data);
-};
</code></pre>
<p>削除した部分を <code class="notranslate" translate="no">offscreencanvas-worker-cubes.js</code> にコピーして <code class="notranslate" translate="no">shared-cubes.js</code> をインポートし、<code class="notranslate" translate="no">main</code> の代わりに <code class="notranslate" translate="no">init</code> を呼び出します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import {init, state} from &#39;./shared-cubes.js&#39;;

function size(data) {
  state.width = data.width;
  state.height = data.height;
}

const handlers = {
-  main,
+  init,
  size,
};

self.onmessage = function(e) {
  const fn = handlers[e.data.type];
  if (!fn) {
    throw new Error(&#39;no handler for type: &#39; + e.data.type);
  }
  fn(e.data);
};
</code></pre>
<p>同様にメインページに <code class="notranslate" translate="no">shared-cubes.js</code> を含める必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;script type=&quot;module&quot;&gt;
+import {init, state} from &#39;./shared-cubes.js&#39;;
</code></pre>
<p>前に追加したHTMLとCSSを削除します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
-  &lt;div id=&quot;noOffscreenCanvas&quot; style=&quot;display:none;&quot;&gt;
-    &lt;div&gt;no OffscreenCanvas support&lt;/div&gt;
-  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>そして、CSSは以下のようになります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">-#noOffscreenCanvas {
-    display: flex;
-    width: 100vw;
-    height: 100vh;
-    align-items: center;
-    justify-content: center;
-    background: red;
-    color: white;
-}
</code></pre>
<p>次にブラウザが <code class="notranslate" translate="no">OffscreenCanvas</code> をサポートありなしに応じて、メインページのコードを変更して起動関数を呼び出すようにしてみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
-  if (!canvas.transferControlToOffscreen) {
-    canvas.style.display = &#39;none&#39;;
-    document.querySelector(&#39;#noOffscreenCanvas&#39;).style.display = &#39;&#39;;
-    return;
-  }
-  const offscreen = canvas.transferControlToOffscreen();
-  const worker = new Worker(&#39;offscreencanvas-picking.js&#39;, {type: &#39;module&#39;});
-  worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);
+  if (canvas.transferControlToOffscreen) {
+    startWorker(canvas);
+  } else {
+    startMainPage(canvas);
+  }
  ...
</code></pre>
<p>Workerのセットアップコードを全て <code class="notranslate" translate="no">startWorker</code> の中に移動します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function startWorker(canvas) {
  const offscreen = canvas.transferControlToOffscreen();
  const worker = new Worker(&#39;offscreencanvas-worker-cubes.js&#39;, {type: &#39;module&#39;});
  worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);

  function sendSize() {
    worker.postMessage({
      type: &#39;size&#39;,
      width: canvas.clientWidth,
      height: canvas.clientHeight,
    });
  }

  window.addEventListener(&#39;resize&#39;, sendSize);
  sendSize();

  console.log(&#39;using OffscreenCanvas&#39;);
}
</code></pre>
<p>そして <code class="notranslate" translate="no">main</code> の代わりに <code class="notranslate" translate="no">init</code> を送信します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-  worker.postMessage({type: &#39;main&#39;, canvas: offscreen}, [offscreen]);
+  worker.postMessage({type: &#39;init&#39;, canvas: offscreen}, [offscreen]);
</code></pre>
<p>メインページで開始するには次のようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function startMainPage(canvas) {
  init({canvas});

  function sendSize() {
    state.width = canvas.clientWidth;
    state.height = canvas.clientHeight;
  }
  window.addEventListener(&#39;resize&#39;, sendSize);
  sendSize();

  console.log(&#39;using regular canvas&#39;);
}
</code></pre>
<p>このサンプルコードではOffscreenCanvasで実行、またはメインページで実行されるようにフォールバックしています。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-offscreencanvas-w-fallback.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-offscreencanvas-w-fallback.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>比較的簡単でした。ピッキングしてみましょう。
<a href="threejs-picking.html">ピッキングの記事</a>にある <code class="notranslate" translate="no">RayCaster</code> の例からコードをいくつか取り出し、画面外でオフスクリーンが動作するようにします。</p>
<p><code class="notranslate" translate="no">shared-cube.js</code> を <code class="notranslate" translate="no">shared-picking.js</code> にコピーし、ピッキング部分を追加してみましょう。
この例では <code class="notranslate" translate="no">PickHelper</code> をコピーします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class PickHelper {
  constructor() {
    this.raycaster = new THREE.Raycaster();
    this.pickedObject = null;
    this.pickedObjectSavedColor = 0;
  }
  pick(normalizedPosition, scene, camera, time) {
    // restore the color if there is a picked object
    if (this.pickedObject) {
      this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
      this.pickedObject = undefined;
    }

    // cast a ray through the frustum
    this.raycaster.setFromCamera(normalizedPosition, camera);
    // get the list of objects the ray intersected
    const intersectedObjects = this.raycaster.intersectObjects(scene.children);
    if (intersectedObjects.length) {
      // pick the first object. It&#39;s the closest one
      this.pickedObject = intersectedObjects[0].object;
      // save its color
      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
      // set its emissive color to flashing red/yellow
      this.pickedObject.material.emissive.setHex((time * 8) % 2 &gt; 1 ? 0xFFFF00 : 0xFF0000);
    }
  }
}

const pickPosition = {x: 0, y: 0};
const pickHelper = new PickHelper();
</code></pre>
<p>マウスの <code class="notranslate" translate="no">pickPosition</code> を以下のように更新しました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function setPickPosition(event) {
  const pos = getCanvasRelativePosition(event);
  pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
  pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
}
window.addEventListener(&#39;mousemove&#39;, setPickPosition);
</code></pre>
<p>Workerではマウスの位置を直接読み取れないので、サイズのコードと同じようにマウスの位置を指定してメッセージを送信してみましょう。
サイズのコードと同様にマウスの位置を送信して <code class="notranslate" translate="no">pickPosition</code> を更新します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function size(data) {
  state.width = data.width;
  state.height = data.height;
}

+function mouse(data) {
+  pickPosition.x = data.x;
+  pickPosition.y = data.y;
+}

const handlers = {
  init,
+  mouse,
  size,
};

self.onmessage = function(e) {
  const fn = handlers[e.data.type];
  if (!fn) {
    throw new Error(&#39;no handler for type: &#39; + e.data.type);
  }
  fn(e.data);
};
</code></pre>
<p>メインページに戻ってマウスをWorkerやメインページに渡すコードを追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+let sendMouse;

function startWorker(canvas) {
  const offscreen = canvas.transferControlToOffscreen();
  const worker = new Worker(&#39;offscreencanvas-worker-picking.js&#39;, {type: &#39;module&#39;});
  worker.postMessage({type: &#39;init&#39;, canvas: offscreen}, [offscreen]);

+  sendMouse = (x, y) =&gt; {
+    worker.postMessage({
+      type: &#39;mouse&#39;,
+      x,
+      y,
+    });
+  };

  function sendSize() {
    worker.postMessage({
      type: &#39;size&#39;,
      width: canvas.clientWidth,
      height: canvas.clientHeight,
    });
  }

  window.addEventListener(&#39;resize&#39;, sendSize);
  sendSize();

  console.log(&#39;using OffscreenCanvas&#39;);  /* eslint-disable-line no-console */
}

function startMainPage(canvas) {
  init({canvas});

+  sendMouse = (x, y) =&gt; {
+    pickPosition.x = x;
+    pickPosition.y = y;
+  };

  function sendSize() {
    state.width = canvas.clientWidth;
    state.height = canvas.clientHeight;
  }
  window.addEventListener(&#39;resize&#39;, sendSize);
  sendSize();

  console.log(&#39;using regular canvas&#39;);  /* eslint-disable-line no-console */
}
</code></pre>
<p>全てのマウス操作コードをメインページにコピーし、<code class="notranslate" translate="no">sendMouse</code> を使用するようにマイナーチェンジを加えます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setPickPosition(event) {
  const pos = getCanvasRelativePosition(event);
-  pickPosition.x = (pos.x / canvas.clientWidth ) *  2 - 1;
-  pickPosition.y = (pos.y / canvas.clientHeight) * -2 + 1;  // note we flip Y
+  sendMouse(
+      (pos.x / canvas.clientWidth ) *  2 - 1,
+      (pos.y / canvas.clientHeight) * -2 + 1);  // note we flip Y
}

function clearPickPosition() {
  // unlike the mouse which always has a position
  // if the user stops touching the screen we want
  // to stop picking. For now we just pick a value
  // unlikely to pick something
-  pickPosition.x = -100000;
-  pickPosition.y = -100000;
+  sendMouse(-100000, -100000);
}
window.addEventListener(&#39;mousemove&#39;, setPickPosition);
window.addEventListener(&#39;mouseout&#39;, clearPickPosition);
window.addEventListener(&#39;mouseleave&#39;, clearPickPosition);

window.addEventListener(&#39;touchstart&#39;, (event) =&gt; {
  // prevent the window from scrolling
  event.preventDefault();
  setPickPosition(event.touches[0]);
}, {passive: false});

window.addEventListener(&#39;touchmove&#39;, (event) =&gt; {
  setPickPosition(event.touches[0]);
});

window.addEventListener(&#39;touchend&#39;, clearPickPosition);
</code></pre>
<p>これでこのピッキングは <code class="notranslate" translate="no">OffscreenCanvas</code> で動作するはずです。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-offscreencanvas-w-picking.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-offscreencanvas-w-picking.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>もう1歩踏み込んで <code class="notranslate" translate="no">OrbitControls</code> を追加してみましょう。
これはもう少し複雑です。
<code class="notranslate" translate="no">OrbitControls</code> はマウス、タッチイベント、キーボードなどDOMをかなり広範囲にチェックしています。</p>
<p>これまでのコードとは異なり、グローバルな <code class="notranslate" translate="no">state</code> オブジェクトを使う事はできません。
これを使用して動作するようにOrbitControlsのコードを全て書き換える必要はありません。
OrbitControlsは <code class="notranslate" translate="no">HTMLElement</code> を取り、それに使用するDOMイベントのほとんどをアタッチします。
OrbitControlsが必要とする機能をサポートする必要があります。</p>
<p><a href="https://github.com/gfxfundamentals/threejsfundamentals/blob/master/threejs/resources/threejs/r122/examples/js/controls/OrbitControls.js">OrbitControlsのソースコード</a>を掘り下げてみると、次のイベントを処理する必要があるように見えます。</p>
<ul>
<li>contextmenu</li>
<li>mousedown</li>
<li>mousemove</li>
<li>mouseup</li>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
<li>wheel</li>
<li>keydown</li>
</ul>
<p>マウスイベントには <code class="notranslate" translate="no">ctrlKey</code>、 <code class="notranslate" translate="no">metaKey</code>、 <code class="notranslate" translate="no">shiftKey</code>、 <code class="notranslate" translate="no">button</code>、 <code class="notranslate" translate="no">clientX</code>、 <code class="notranslate" translate="no">clientY</code>、 <code class="notranslate" translate="no">pageX</code>、 <code class="notranslate" translate="no">pageY</code> プロパティが必要です。</p>
<p>キーダウンイベントには <code class="notranslate" translate="no">ctrlKey</code>, <code class="notranslate" translate="no">metaKey</code>, <code class="notranslate" translate="no">shiftKey</code>, <code class="notranslate" translate="no">keyCode</code> プロパティが必要です。</p>
<p>ホイールイベントに必要なのは <code class="notranslate" translate="no">deltaY</code> プロパティだけです。</p>
<p>また、タッチイベントに必要なのは <code class="notranslate" translate="no">touches</code> プロパティの <code class="notranslate" translate="no">pageX</code> と <code class="notranslate" translate="no">pageY</code> だけです。</p>
<p>そこでproxyオブジェクトのペアを作ってみましょう。
ある時はメインページで実行され、全てのイベント、関連するプロパティ値をWorkerに渡します。
また、ある時はWorkerで実行され、全てのイベント、DOMイベントと同じ構造をもつイベントをメインページに渡すので、OrbitControlsは違いを見分けられません。</p>
<p>ここにWorker部分のコードがあります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import {EventDispatcher} from &#39;./resources/threejs/r122/build/three.module.js&#39;;

class ElementProxyReceiver extends EventDispatcher {
  constructor() {
    super();
  }
  handleEvent(data) {
    this.dispatchEvent(data);
  }
}
</code></pre>
<p>メッセージを受信した場合にdataを送信するだけです。
これは <code class="notranslate" translate="no">EventDispatcher</code> を継承しており、DOM要素のように <code class="notranslate" translate="no">addEventListener</code> や <code class="notranslate" translate="no">removeEventListener</code> のようなメソッドを提供しているので、OrbitControlsに渡せば動作するはずです。</p>
<p><code class="notranslate" translate="no">ElementProxyReceiver</code> は1つの要素を扱います。
私たちの場合は1つの頭しか必要ありませんが、頭で考えるのがベストです。
つまり、マネージャーを作って複数のElementProxyReceiverを管理するようにしましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class ProxyManager {
  constructor() {
    this.targets = {};
    this.handleEvent = this.handleEvent.bind(this);
  }
  makeProxy(data) {
    const {id} = data;
    const proxy = new ElementProxyReceiver();
    this.targets[id] = proxy;
  }
  getProxy(id) {
    return this.targets[id];
  }
  handleEvent(data) {
    this.targets[data.id].handleEvent(data.data);
  }
}
</code></pre>
<p><code class="notranslate" translate="no">ProxyManager</code>のインスタンスを作成し <code class="notranslate" translate="no">makeProxy</code> メソッドにidを指定して呼び出す事で、そのidを持つメッセージに応答する <code class="notranslate" translate="no">ElementProxyReceiver</code> を作成できます。</p>
<p>Workerのメッセージハンドラに接続してみましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const proxyManager = new ProxyManager();

function start(data) {
  const proxy = proxyManager.getProxy(data.canvasId);
  init({
    canvas: data.canvas,
    inputElement: proxy,
  });
}

function makeProxy(data) {
  proxyManager.makeProxy(data);
}

...

const handlers = {
-  init,
-  mouse,
+  start,
+  makeProxy,
+  event: proxyManager.handleEvent,
   size,
};

self.onmessage = function(e) {
  const fn = handlers[e.data.type];
  if (!fn) {
    throw new Error(&#39;no handler for type: &#39; + e.data.type);
  }
  fn(e.data);
};
</code></pre>
<p>共有のthree.jsコードでは <code class="notranslate" translate="no">OrbitControls</code> をインポートして設定する必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import * as THREE from &#39;./resources/threejs/r122/build/three.module.js&#39;;
+import {OrbitControls} from &#39;./resources/threejs/r122/examples/jsm/controls/OrbitControls.js&#39;;

export function init(data) {
-  const {canvas} = data;
+  const {canvas, inputElement} = data;
  const renderer = new THREE.WebGLRenderer({canvas});

+  const controls = new OrbitControls(camera, inputElement);
+  controls.target.set(0, 0, 0);
+  controls.update();
</code></pre>
<p>OffscreenCanvas以外のサンプルコード例のようにキャンバスを渡すのではなく、
<code class="notranslate" translate="no">inputElement</code> を介してOrbitControlsをProxyに渡している事に注目して下さい。</p>
<p>次に <code class="notranslate" translate="no">canvas</code> を <code class="notranslate" translate="no">inputElement</code> に変更し、HTMLファイルから全てのピッキングイベントのコードを共有のthree.jsコードに移動させます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function getCanvasRelativePosition(event) {
-  const rect = canvas.getBoundingClientRect();
+  const rect = inputElement.getBoundingClientRect();
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  };
}

function setPickPosition(event) {
  const pos = getCanvasRelativePosition(event);
-  sendMouse(
-      (pos.x / canvas.clientWidth ) *  2 - 1,
-      (pos.y / canvas.clientHeight) * -2 + 1);  // note we flip Y
+  pickPosition.x = (pos.x / inputElement.clientWidth ) *  2 - 1;
+  pickPosition.y = (pos.y / inputElement.clientHeight) * -2 + 1;  // note we flip Y
}

function clearPickPosition() {
  // unlike the mouse which always has a position
  // if the user stops touching the screen we want
  // to stop picking. For now we just pick a value
  // unlikely to pick something
-  sendMouse(-100000, -100000);
+  pickPosition.x = -100000;
+  pickPosition.y = -100000;
}

*inputElement.addEventListener(&#39;mousemove&#39;, setPickPosition);
*inputElement.addEventListener(&#39;mouseout&#39;, clearPickPosition);
*inputElement.addEventListener(&#39;mouseleave&#39;, clearPickPosition);

*inputElement.addEventListener(&#39;touchstart&#39;, (event) =&gt; {
  // prevent the window from scrolling
  event.preventDefault();
  setPickPosition(event.touches[0]);
}, {passive: false});

*inputElement.addEventListener(&#39;touchmove&#39;, (event) =&gt; {
  setPickPosition(event.touches[0]);
});

*inputElement.addEventListener(&#39;touchend&#39;, clearPickPosition);
</code></pre>
<p>メインページに戻り、上記で列挙した全てのイベントにメッセージを送信するコードが必要です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let nextProxyId = 0;
class ElementProxy {
  constructor(element, worker, eventHandlers) {
    this.id = nextProxyId++;
    this.worker = worker;
    const sendEvent = (data) =&gt; {
      this.worker.postMessage({
        type: &#39;event&#39;,
        id: this.id,
        data,
      });
    };

    // register an id
    worker.postMessage({
      type: &#39;makeProxy&#39;,
      id: this.id,
    });
    for (const [eventName, handler] of Object.entries(eventHandlers)) {
      element.addEventListener(eventName, function(event) {
        handler(event, sendEvent);
      });
    }
  }
}
</code></pre>
<p><code class="notranslate" translate="no">ElementProxy</code> はProxyしたいイベントの要素を受け取ります。
次にWorkerにidを登録し、先ほど設定した <code class="notranslate" translate="no">makeProxy</code> メッセージを使って送信します。
Workerは <code class="notranslate" translate="no">ElementProxyReceiver</code> を作成しそのidに登録します。</p>
<p>そして登録するイベントハンドラのオブジェクトを用意します。
このようにして、Workerに転送したいイベントにハンドラを渡す事ができます。</p>
<p>Workerを起動する時はまずProxyを作成しイベントハンドラを渡します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function startWorker(canvas) {
  const offscreen = canvas.transferControlToOffscreen();
  const worker = new Worker(&#39;offscreencanvas-worker-orbitcontrols.js&#39;, {type: &#39;module&#39;});

+  const eventHandlers = {
+    contextmenu: preventDefaultHandler,
+    mousedown: mouseEventHandler,
+    mousemove: mouseEventHandler,
+    mouseup: mouseEventHandler,
+    touchstart: touchEventHandler,
+    touchmove: touchEventHandler,
+    touchend: touchEventHandler,
+    wheel: wheelEventHandler,
+    keydown: filteredKeydownEventHandler,
+  };
+  const proxy = new ElementProxy(canvas, worker, eventHandlers);
  worker.postMessage({
    type: &#39;start&#39;,
    canvas: offscreen,
+    canvasId: proxy.id,
  }, [offscreen]);
  console.log(&#39;using OffscreenCanvas&#39;);  /* eslint-disable-line no-console */
}
</code></pre>
<p>以下はイベントハンドラです。
受信したイベントからプロパティのリストをコピーするだけです。
<code class="notranslate" translate="no">sendEvent</code> 関数に渡され作成したデータを渡します。
この関数は正しいidを追加してWorkerに送信します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const mouseEventHandler = makeSendPropertiesHandler([
  &#39;ctrlKey&#39;,
  &#39;metaKey&#39;,
  &#39;shiftKey&#39;,
  &#39;button&#39;,
  &#39;clientX&#39;,
  &#39;clientY&#39;,
  &#39;pageX&#39;,
  &#39;pageY&#39;,
]);
const wheelEventHandlerImpl = makeSendPropertiesHandler([
  &#39;deltaX&#39;,
  &#39;deltaY&#39;,
]);
const keydownEventHandler = makeSendPropertiesHandler([
  &#39;ctrlKey&#39;,
  &#39;metaKey&#39;,
  &#39;shiftKey&#39;,
  &#39;keyCode&#39;,
]);

function wheelEventHandler(event, sendFn) {
  event.preventDefault();
  wheelEventHandlerImpl(event, sendFn);
}

function preventDefaultHandler(event) {
  event.preventDefault();
}

function copyProperties(src, properties, dst) {
  for (const name of properties) {
      dst[name] = src[name];
  }
}

function makeSendPropertiesHandler(properties) {
  return function sendProperties(event, sendFn) {
    const data = {type: event.type};
    copyProperties(event, properties, data);
    sendFn(data);
  };
}

function touchEventHandler(event, sendFn) {
  const touches = [];
  const data = {type: event.type, touches};
  for (let i = 0; i &lt; event.touches.length; ++i) {
    const touch = event.touches[i];
    touches.push({
      pageX: touch.pageX,
      pageY: touch.pageY,
    });
  }
  sendFn(data);
}

// The four arrow keys
const orbitKeys = {
  &#39;37&#39;: true,  // left
  &#39;38&#39;: true,  // up
  &#39;39&#39;: true,  // right
  &#39;40&#39;: true,  // down
};
function filteredKeydownEventHandler(event, sendFn) {
  const {keyCode} = event;
  if (orbitKeys[keyCode]) {
    event.preventDefault();
    keydownEventHandler(event, sendFn);
  }
}
</code></pre>
<p>これで動くと思われるが、実際に試してみると <code class="notranslate" translate="no">OrbitControls</code> がもう少し必要なものがあると分かります。</p>
<p>1つは <code class="notranslate" translate="no">element.focus</code> です。Workerには必要ないのでStubを追加しておきましょう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class ElementProxyReceiver extends THREE.EventDispatcher {
  constructor() {
    super();
  }
  handleEvent(data) {
    this.dispatchEvent(data);
  }
+  focus() {
+    // no-op
+  }
}
</code></pre>
<p>もう1つは <code class="notranslate" translate="no">event.preventDefault</code> と <code class="notranslate" translate="no">event.stopPropagation</code> を呼び出す事です。
メインページでは既に対応してるのでそれらも不要になります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function noop() {
+}

class ElementProxyReceiver extends THREE.EventDispatcher {
  constructor() {
    super();
  }
  handleEvent(data) {
+    data.preventDefault = noop;
+    data.stopPropagation = noop;
    this.dispatchEvent(data);
  }
  focus() {
    // no-op
  }
}
</code></pre>
<p>もう1つは <code class="notranslate" translate="no">clientWidth</code> と <code class="notranslate" translate="no">clientHeight</code> を見る事です。
以前はサイズを渡してましたが、Proxyペアを更新してそれも渡すようにします。</p>
<p>Workerの中では</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class ElementProxyReceiver extends THREE.EventDispatcher {
  constructor() {
    super();
  }
+  get clientWidth() {
+    return this.width;
+  }
+  get clientHeight() {
+    return this.height;
+  }
+  getBoundingClientRect() {
+    return {
+      left: this.left,
+      top: this.top,
+      width: this.width,
+      height: this.height,
+      right: this.left + this.width,
+      bottom: this.top + this.height,
+    };
+  }
  handleEvent(data) {
+    if (data.type === &#39;size&#39;) {
+      this.left = data.left;
+      this.top = data.top;
+      this.width = data.width;
+      this.height = data.height;
+      return;
+    }
    data.preventDefault = noop;
    data.stopPropagation = noop;
    this.dispatchEvent(data);
  }
  focus() {
    // no-op
  }
}
</code></pre>
<p>メインページに戻るにはサイズと左と上の位置も送信する必要があります。
このままではキャンバスを移動しても処理されず、サイズを変更しても処理されないです。
移動を処理したい場合は何かがキャンバスを移動する度に <code class="notranslate" translate="no">sendSize</code> を呼び出す必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class ElementProxy {
  constructor(element, worker, eventHandlers) {
    this.id = nextProxyId++;
    this.worker = worker;
    const sendEvent = (data) =&gt; {
      this.worker.postMessage({
        type: &#39;event&#39;,
        id: this.id,
        data,
      });
    };

    // register an id
    worker.postMessage({
      type: &#39;makeProxy&#39;,
      id: this.id,
    });
+    sendSize();
    for (const [eventName, handler] of Object.entries(eventHandlers)) {
      element.addEventListener(eventName, function(event) {
        handler(event, sendEvent);
      });
    }

+    function sendSize() {
+      const rect = element.getBoundingClientRect();
+      sendEvent({
+        type: &#39;size&#39;,
+        left: rect.left,
+        top: rect.top,
+        width: element.clientWidth,
+        height: element.clientHeight,
+      });
+    }
+
+    window.addEventListener(&#39;resize&#39;, sendSize);
  }
}
</code></pre>
<p>そして共有のthree.jsコードでは <code class="notranslate" translate="no">state</code> は不要になりました。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-export const state = {
-  width: 300,   // canvas default
-  height: 150,  // canvas default
-};

...

function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
-  const width = state.width;
-  const height = state.height;
+  const width = inputElement.clientWidth;
+  const height = inputElement.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}

function render(time) {
  time *= 0.001;

  if (resizeRendererToDisplaySize(renderer)) {
-    camera.aspect = state.width / state.height;
+    camera.aspect = inputElement.clientWidth / inputElement.clientHeight;
    camera.updateProjectionMatrix();
  }

  ...
</code></pre>
<p>他にもいくつかのハックがあります。
OrbitControlsは <code class="notranslate" translate="no">mousemove</code> と <code class="notranslate" translate="no">mouseup</code> イベントをマウスキャプチャ（マウスがウィンドウの外に出た時）を処理するための要素の <code class="notranslate" translate="no">ownerDocument</code> です。</p>
<p>さらにコードはグローバルな <code class="notranslate" translate="no">document</code> を参照していますが、Workerにはグローバルなdocumentはありません。</p>
<p>これは2つの簡単なハックで全て解決できます。
Workerコードでは両方の問題に対してProxyを再利用します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function start(data) {
  const proxy = proxyManager.getProxy(data.canvasId);
+  proxy.ownerDocument = proxy; // HACK!
+  self.document = {} // HACK!
  init({
    canvas: data.canvas,
    inputElement: proxy,
  });
}
</code></pre>
<p>これで <code class="notranslate" translate="no">OrbitControls</code> が期待に沿った検査を行うための機能を提供します。</p>
<p>難しいのは分かっていますが手短に言うと:</p>
<p><code class="notranslate" translate="no">ElementProxy</code> はメインページ上で動作し、DOMイベントを転送します。
Worker内の <code class="notranslate" translate="no">ElementProxyReceiver</code> は一緒に使うことができる <code class="notranslate" translate="no">HTMLElement</code> を装っています。
<code class="notranslate" translate="no">OrbitControls</code> と独自のコードを使用しています。</p>
<p>最後にOffscreenCanvasを使用していない時のフォールバックです。
必要なのはcanvas自体を <code class="notranslate" translate="no">inputElement</code> として渡す事です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function startMainPage(canvas) {
-  init({canvas});
+  init({canvas, inputElement: canvas});
  console.log(&#39;using regular canvas&#39;);
}
</code></pre>
<p>これでOrbitControlsがOffscreenCanvasで動作するようになりました。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-offscreencanvas-w-orbitcontrols.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-offscreencanvas-w-orbitcontrols.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>これはおそらくこのサイトで最も複雑な例です。
各サンプルには3つのファイルが含まれているので少しわかりにくいです。
HTMLファイル、Workerファイル、共有のthree.jsコードなどです。</p>
<p>理解する事が難し過ぎず、少しでも参考になれば幸いです。
three.js、OffscreenCanvas、Web Workerを使った動作の便利な例を紹介しました。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-offscreencanvas.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-offscreencanvas.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-offscreencanvas.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-offscreencanvas.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-offscreencanvas.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-offscreencanvas.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-fundamentals.html">基礎知識</a></li>
<li><a href="/threejs/lessons/ja/threejs-responsive.html">レスポンシブデザイン</a></li>
<li><a href="/threejs/lessons/ja/threejs-prerequisites.html">前提条件</a></li>
<li><a href="/threejs/lessons/ja/threejs-setup.html">セットアップ</a></li>
        </ul>
  <li>基礎</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-primitives.html">プリミティブ</a></li>
<li><a href="/threejs/lessons/ja/threejs-scenegraph.html">シーングラフ</a></li>
<li><a href="/threejs/lessons/ja/threejs-materials.html">マテリアル</a></li>
<li><a href="/threejs/lessons/ja/threejs-textures.html">テクスチャ</a></li>
<li><a href="/threejs/lessons/ja/threejs-lights.html">ライト</a></li>
<li><a href="/threejs/lessons/ja/threejs-cameras.html">カメラ</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadows.html">Shadows</a></li>
<li><a href="/threejs/lessons/ja/threejs-fog.html">Fog</a></li>
<li><a href="/threejs/lessons/ja/threejs-rendertargets.html">Render Targets</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-geometry.html">Custom Geometry</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-buffergeometry.html">Custom BufferGeometry</a></li>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-rendering-on-demand.html">要求されたレンダリング</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-javascript.html">JavaScriptのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-glsl.html">GLSLのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#screenshot">スクリーンショットを撮る</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#preservedrawingbuffer">キャンバスがクリアされるのを防ぐ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#tabindex">キャンバスからキーボード入力を取得する</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#transparent-canvas">キャンバスを透明にする</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#html-background">HTMLの背景にthree.jsを使う</a></li>
        </ul>
  <li>最適化</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects.html">多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html">アニメーションする多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-offscreencanvas.html">Web WorkerでOffscreenCanvasを使用する</a></li>
        </ul>
  <li>解決策</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-load-obj.html">OBJファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-load-gltf.html">GLTFファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-backgrounds.html">背景やスカイボックスを追加する</a></li>
<li><a href="/threejs/lessons/ja/threejs-transparency.html">透明なオブジェクトの描画方法</a></li>
<li><a href="/threejs/lessons/ja/threejs-multiple-scenes.html">複数キャンバスと複数シーン</a></li>
<li><a href="/threejs/lessons/ja/threejs-picking.html">マウスでオブジェクトをピッキング</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing.html">ポストプロセス</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing-3dlut.html">エフェクトにLUTファイルを適用する</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ja/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ja/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ja/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ja/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ja/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ja/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ja/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>参照</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-material-table.html">Material Table</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.jsドキュメント</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>質問はありますか? <a href="http://stackoverflow.com/questions/tagged/three.js">何かあればstackoverflowで尋ねて下さい</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/threefundamentals/issues">またはgithubでissueを作って下さい</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.jsのOffscreenCanvas';
            var disqus_title = 'Three.jsのOffscreenCanvas';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "threejsfundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



