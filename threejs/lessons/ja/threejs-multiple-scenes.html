<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ja/threejs-multiple-scenes.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="THREE.jsでページ全体にものを描画する方法">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-multiple-scenes_ja.jpg">

<meta property="og:title" content="Three.jsの複数キャンバスと複数シーン">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-multiple-scenes_ja.jpg">
<meta property="og:description" content="THREE.jsでページ全体にものを描画する方法">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.jsの複数キャンバスと複数シーン">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html">
<meta name="twitter:description" content="THREE.jsでページ全体にものを描画する方法">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-multiple-scenes_ja.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-multiple-scenes.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-multiple-scenes.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-multiple-scenes.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-multiple-scenes.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-multiple-scenes.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-multiple-scenes_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html",
      "inLanguage":"ja",
      "name":"Three.jsの複数キャンバスと複数シーン",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-multiple-scenes.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.jsの複数キャンバスと複数シーン</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-multiple-scenes.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-multiple-scenes.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-multiple-scenes.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-multiple-scenes.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-multiple-scenes.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-multiple-scenes.html" >中文</a>
</select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ja/">threejsfundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.jsの複数キャンバスと複数シーン</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>よくある質問として、どうやってThree.jsで複数キャンバスを使用するのかがあります。
ECサイトを作りたい、3Dダイアグラムをたくさん使ったページを作りたいとしましょう。
一見簡単そうに見えます。
ダイアグラムが欲しい所にキャンバスを作るだけです。
それぞれのキャンバスで <code class="notranslate" translate="no">Renderer</code> を作成します。</p>
<p>以下の問題にすぐに気づくでしょう。</p>
<ol>
<li><p>ブラウザはWebGLコンテキスト数を制限している</p>
<p> 一般的にはコンテキスト数の制限は約8個です。
 9個目のコンテキストを作成すると、すぐに古いコンテキストが失われます。</p>
</li>
<li><p>WebGLリソースはコンテキスト間で共有できない</p>
<p> 10MBの3Dモデルを2つのキャンバスにロードしたいとします。
 20MBのテクスチャを持ち、10MBの3Dモデルも20MBのテクステャも2回ロードしなければなりません。
 コンテキスト間で共有はできません。
 つまり、初期化もシェーダーコンパイルも2回する必要があります。
 キャンバスが増えると回数が増えさらに悪化します。</p>
</li>
</ol>
<p>何か解決策はないでしょうか？</p>
<p>解決策としては、背景のViewPortを埋める1つのキャンバスと、キャンバス以外のHTML要素で&quot;仮想&quot;のキャンバスを持つ事です。
仮想キャンバスごとに <code class="notranslate" translate="no">Renderer</code> と <code class="notranslate" translate="no">Scene</code> を1つずつ作成します。
次に仮想キャンバス要素の位置を確認し、その要素が画面上にある場合はシーンの正しい場所に描画するようにします。</p>
<p>この解決策はキャンバスが1つしかないため、上記の1と2の問題を解決します。
1つのコンテキストだけなので、WebGLコンテキストの制限は問題ありません。
同じ理由で共有の問題もありません。</p>
<p>2つのシーンだけの簡単な例から始めましょう。まずはHTMLを作成します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
&lt;p&gt;
  &lt;span id=&quot;box&quot; class=&quot;diagram left&quot;&gt;&lt;/span&gt;
  I love boxes. Presents come in boxes.
  When I find a new box I&#39;m always excited to find out what&#39;s inside.
&lt;/p&gt;
&lt;p&gt;
  &lt;span id=&quot;pyramid&quot; class=&quot;diagram right&quot;&gt;&lt;/span&gt;
  When I was a kid I dreamed of going on an expedition inside a pyramid
  and finding a undiscovered tomb full of mummies and treasure.
&lt;/p&gt;
</code></pre>
<p>次にCSSを次のように設定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">#c {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: block;
  z-index: -1;
}
.diagram {
  display: inline-block;
  width: 5em;
  height: 3em;
  border: 1px solid black;
}
.left {
  float: left;
  margin-right: .25em;
}
.right {
  float: right;
  margin-left: .25em;
}
</code></pre>
<p>キャンバスを画面一杯にし、<code class="notranslate" translate="no">z-index</code> を-1に設定し他のDOM要素よりも後に表示されるようにします。
仮想キャンバスにはサイズ指定がないため、幅と高さを指定する必要があります。</p>
<p>次にライトとカメラをそれぞれ2つのシーンに作成します。
1つ目のシーンにキューブを追加し、もう1つのシーンにはひし形を追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeScene(elem) {
  const scene = new THREE.Scene();

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;
  camera.position.set(0, 1, 2);
  camera.lookAt(0, 0, 0);

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);
  }

  return {scene, camera, elem};
}

function setupScene1() {
  const sceneInfo = makeScene(document.querySelector(&#39;#box&#39;));
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  const material = new THREE.MeshPhongMaterial({color: &#39;red&#39;});
  const mesh = new THREE.Mesh(geometry, material);
  sceneInfo.scene.add(mesh);
  sceneInfo.mesh = mesh;
  return sceneInfo;
}

function setupScene2() {
  const sceneInfo = makeScene(document.querySelector(&#39;#pyramid&#39;));
  const radius = .8;
  const widthSegments = 4;
  const heightSegments = 2;
  const geometry = new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments);
  const material = new THREE.MeshPhongMaterial({
    color: &#39;blue&#39;,
    flatShading: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  sceneInfo.scene.add(mesh);
  sceneInfo.mesh = mesh;
  return sceneInfo;
}

const sceneInfo1 = setupScene1();
const sceneInfo2 = setupScene2();
</code></pre>
<p>DOM要素が画面上にある場合のみ、各シーンをレンダリングする関数を作成します。
<code class="notranslate" translate="no">Renderer.setScissorTest</code> で <em>シザー</em> テストを有効にし、キャンバスの一部だけをレンダリングするように指定できます。
<code class="notranslate" translate="no">Renderer.setViewport</code> と <code class="notranslate" translate="no">Renderer.setScissor</code> でシザーとビューポートの両方を設定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function renderSceneInfo(sceneInfo) {
  const {scene, camera, elem} = sceneInfo;

  // get the viewport relative position of this element
  const {left, right, top, bottom, width, height} =
      elem.getBoundingClientRect();

  const isOffscreen =
      bottom &lt; 0 ||
      top &gt; renderer.domElement.clientHeight ||
      right &lt; 0 ||
      left &gt; renderer.domElement.clientWidth;

  if (isOffscreen) {
    return;
  }

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  const positiveYUpBottom = canvasRect.height - bottom;
  renderer.setScissor(left, positiveYUpBottom, width, height);
  renderer.setViewport(left, positiveYUpBottom, width, height);

  renderer.render(scene, camera);
}
</code></pre>
<p>render関数で最初に画面をクリア後、各シーンをレンダリングします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;

  resizeRendererToDisplaySize(renderer);

  renderer.setScissorTest(false);
  renderer.clear(true, true);
  renderer.setScissorTest(true);

  sceneInfo1.mesh.rotation.y = time * .1;
  sceneInfo2.mesh.rotation.y = time * .1;

  renderSceneInfo(sceneInfo1);
  renderSceneInfo(sceneInfo2);

  requestAnimationFrame(render);
}
</code></pre>
<p>その結果がこれです。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-multiple-scenes-v1.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-multiple-scenes-v1.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>最初の <code class="notranslate" translate="no">&lt;span&gt;</code> が赤いキューブ、2つ目の <code class="notranslate" translate="no">span</code> が青いひし形です。</p>
<h2 id="-">同期する</h2>
<p>上記のコードは動作していますが、1つだけ小さな問題があります。
シーンが複雑だったり、何らかの理由でレンダリングに時間がかかり過ぎる場合、
キャンバスに描画したシーンの位置が他のページよりも遅れてしまいます。</p>
<p>各エリアにborderを与えて</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">.diagram {
  display: inline-block;
  width: 5em;
  height: 3em;
+  border: 1px solid black;
}
</code></pre>
<p>各シーンに背景色を設定します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const scene = new THREE.Scene();
+scene.background = new THREE.Color(&#39;red&#39;);
</code></pre>
<p>そして、<a href="../../threejs-multiple-scenes-v2.html" target="_blank">素早く上下にスクロール</a>すると問題が分かります。以下はスクロールが10倍に遅くなった動画です。</p>
<div class="threejs_center"><img class="border" src="../resources/images/multi-view-skew.gif"></div>

<p>別のトレードオフになる別の方法に切り替える事もできます。
キャンバスのCSSを <code class="notranslate" translate="no">position: fixed</code> から <code class="notranslate" translate="no">position: absolute</code> に切り替えます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">#c {
-  position: fixed;
+  position: absolute;
</code></pre>
<p>キャンバスの変形を設定し、キャンバス上部が現在のページスクロールしている部分の上部にくるように移動させます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  ...

  const transform = `translateY(${window.scrollY}px)`;
  renderer.domElement.style.transform = transform;
</code></pre>
<p><code class="notranslate" translate="no">position: fixed</code> はページの残りの部分がスクロールしている間、キャンバスがスクロールしないようにしていました。
<code class="notranslate" translate="no">position: absolute</code> は、キャンバスをページの残りの部分と一緒にスクロールさせます。
これはレンダリングに時間がかかりすぎても、描画したものがスクロールしてもページに密着します。
ページがスクロールされた位置に合わせてキャンバスを移動し再レンダリングします。
ウィンドウの端だけが一瞬レンダリングされていないビットが表示されますが、<a href="../../threejs-multiple-scenes-v2.html" target="_blank">ページの真ん中にあるものは一致している</a>のでスライドしません。新しい方法で10倍に遅くなった結果を見てみましょう。</p>
<div class="threejs_center"><img class="border" src="../resources/images/multi-view-fixed.gif"></div>

<h2 id="-">もっと汎用的なコードにする</h2>
<p>複数のシーンが機能したので、もう少し汎用的なコードにしてみましょう。</p>
<p>キャンバスを管理するメインのrender関数にDOM要素のリストと関連するrender関数だけ持たせる事ができます。
各要素に対して画面上に表示されているかチェックし、表示されている場合は対応するrender関数を呼び出します。
この方法は個々のシーンが小さな空間でレンダリングされている事を意識せず、汎用的なシステムになります。</p>
<p>これがメインのrender関数です。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sceneElements = [];
function addScene(elem, fn) {
  sceneElements.push({elem, fn});
}

function render(time) {
  time *= 0.001;

  resizeRendererToDisplaySize(renderer);

  renderer.setScissorTest(false);
  renderer.setClearColor(clearColor, 0);
  renderer.clear(true, true);
  renderer.setScissorTest(true);

  const transform = `translateY(${window.scrollY}px)`;
  renderer.domElement.style.transform = transform;

  for (const {elem, fn} of sceneElements) {
    // get the viewport relative position of this element
    const rect = elem.getBoundingClientRect();
    const {left, right, top, bottom, width, height} = rect;

    const isOffscreen =
        bottom &lt; 0 ||
        top &gt; renderer.domElement.clientHeight ||
        right &lt; 0 ||
        left &gt; renderer.domElement.clientWidth;

    if (!isOffscreen) {
      const positiveYUpBottom = renderer.domElement.clientHeight - bottom;
      renderer.setScissor(left, positiveYUpBottom, width, height);
      renderer.setViewport(left, positiveYUpBottom, width, height);

      fn(time, rect);
    }
  }

  requestAnimationFrame(render);
}
</code></pre>
<p><code class="notranslate" translate="no">elem</code> と<code class="notranslate" translate="no">fn</code> プロパティを持つオブジェクトの配列があり、<code class="notranslate" translate="no">sceneElements</code> でループしているのが分かります。</p>
<p>要素が画面上にあるかどうかをチェックします。
画面上にある場合は <code class="notranslate" translate="no">fn</code> を呼び出し、引数に現在の時刻と矩形を渡します。</p>
<p>これで各シーン設定のコードがシーンのリストに追加されます。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const elem = document.querySelector(&#39;#box&#39;);
  const {scene, camera} = makeScene();
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  const material = new THREE.MeshPhongMaterial({color: &#39;red&#39;});
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
  addScene(elem, (time, rect) =&gt; {
    camera.aspect = rect.width / rect.height;
    camera.updateProjectionMatrix();
    mesh.rotation.y = time * .1;
    renderer.render(scene, camera);
  });
}

{
  const elem = document.querySelector(&#39;#pyramid&#39;);
  const {scene, camera} = makeScene();
  const radius = .8;
  const widthSegments = 4;
  const heightSegments = 2;
  const geometry = new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments);
  const material = new THREE.MeshPhongMaterial({
    color: &#39;blue&#39;,
    flatShading: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
  addScene(elem, (time, rect) =&gt; {
    camera.aspect = rect.width / rect.height;
    camera.updateProjectionMatrix();
    mesh.rotation.y = time * .1;
    renderer.render(scene, camera);
  });
}
</code></pre>
<p><code class="notranslate" translate="no">sceneInfo1</code> と <code class="notranslate" translate="no">sceneInfo2</code> が不要になり、メッシュを回転させていたコードがシーンごとに固有になりました。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-multiple-scenes-generic.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-multiple-scenes-generic.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<h2 id="html-dataset-">HTML Datasetを使う</h2>
<p>最後にもっと汎用的にするためにHTML <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset">dataset</a>を使います。
これはHTML要素に独自のデータを追加する方法です。
<code class="notranslate" translate="no">id=&quot;....&quot;</code> の代わりに <code class="notranslate" translate="no">data-diagram=&quot;....&quot;</code> を使います。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
&lt;p&gt;
-  &lt;span id=&quot;box&quot; class=&quot;diagram left&quot;&gt;&lt;/span&gt;
+  &lt;span data-diagram=&quot;box&quot; class=&quot;left&quot;&gt;&lt;/span&gt;
  I love boxes. Presents come in boxes.
  When I find a new box I&#39;m always excited to find out what&#39;s inside.
&lt;/p&gt;
&lt;p&gt;
-  &lt;span id=&quot;pyramid&quot; class=&quot;diagram left&quot;&gt;&lt;/span&gt;
+  &lt;span data-diagram=&quot;pyramid&quot; class=&quot;right&quot;&gt;&lt;/span&gt;
  When I was a kid I dreamed of going on an expedition inside a pyramid
  and finding a undiscovered tomb full of mummies and treasure.
&lt;/p&gt;
</code></pre>
<p>CSSのセレクタを変更し、それを選択するようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">-.diagram
+*[data-diagram] {
  display: inline-block;
  width: 5em;
  height: 3em;
}
</code></pre>
<p>シーン設定のコードを変更して <em>シーン初期化関数</em> への名前のマップにします。
そして、<em>シーンのレンダリング関数</em> を返すようにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sceneInitFunctionsByName = {
  &#39;box&#39;: () =&gt; {
    const {scene, camera} = makeScene();
    const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
    const material = new THREE.MeshPhongMaterial({color: &#39;red&#39;});
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return (time, rect) =&gt; {
      mesh.rotation.y = time * .1;
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };
  },
  &#39;pyramid&#39;: () =&gt; {
    const {scene, camera} = makeScene();
    const radius = .8;
    const widthSegments = 4;
    const heightSegments = 2;
    const geometry = new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments);
    const material = new THREE.MeshPhongMaterial({
      color: &#39;blue&#39;,
      flatShading: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return (time, rect) =&gt; {
      mesh.rotation.y = time * .1;
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };
  },
};
</code></pre>
<p>次に <code class="notranslate" translate="no">querySelectorAll</code> で全てのdiagramを見つけ、対応するinit関数を呼び出します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">document.querySelectorAll(&#39;[data-diagram]&#39;).forEach((elem) =&gt; {
  const sceneName = elem.dataset.diagram;
  const sceneInitFunction = sceneInitFunctionsByName[sceneName];
  const sceneRenderFunction = sceneInitFunction(elem);
  addScene(elem, sceneRenderFunction);
});
</code></pre>
<p>見た目の変更はありませんが、コードはさらに汎用的になっています。</p>
<p></p>
<h2 id="-">各要素にコントロールを追加する</h2>
<p><code class="notranslate" translate="no">TrackballControls</code> のようなインタラクティブな要素を追加するのは簡単です。
最初にコントロール用のスクリプトを追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import {TrackballControls} from &#39;./resources/threejs/r122/examples/jsm/controls/TrackballControls.js&#39;;
</code></pre>
<p>そして <code class="notranslate" translate="no">TrackballControls</code> を各シーンに追加し、シーンに関連付けられた要素を渡します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function makeScene() {
+function makeScene(elem) {
  const scene = new THREE.Scene();

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 1, 2);
  camera.lookAt(0, 0, 0);
+  scene.add(camera);

+  const controls = new TrackballControls(camera, elem);
+  controls.noZoom = true;
+  controls.noPan = true;

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
-    scene.add(light);
+    camera.add(light);
  }

-  return {scene, camera};
+ return {scene, camera, controls};
}
</code></pre>
<p>シーンにカメラを追加し、カメラにライティングを追加しました。
これにより、カメラに対する相対的な光を受けます。
<code class="notranslate" translate="no">TrackballControls</code> がカメラを動かしているので、これが望んだ形です。
見ている対象物の側に光を当て続けます。</p>
<p>render関数でこれらのコントロールを更新する必要があります。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sceneInitFunctionsByName = {
- &#39;box&#39;: () =&gt; {
-    const {scene, camera} = makeScene();
+ &#39;box&#39;: (elem) =&gt; {
+    const {scene, camera, controls} = makeScene(elem);
    const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
    const material = new THREE.MeshPhongMaterial({color: &#39;red&#39;});
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return (time, rect) =&gt; {
      mesh.rotation.y = time * .1;
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
+      controls.handleResize();
+      controls.update();
      renderer.render(scene, camera);
    };
  },
-  &#39;pyramid&#39;: () =&gt; {
-    const {scene, camera} = makeScene();
+  &#39;pyramid&#39;: (elem) =&gt; {
+    const {scene, camera, controls} = makeScene(elem);
    const radius = .8;
    const widthSegments = 4;
    const heightSegments = 2;
    const geometry = new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments);
    const material = new THREE.MeshPhongMaterial({
      color: &#39;blue&#39;,
      flatShading: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return (time, rect) =&gt; {
      mesh.rotation.y = time * .1;
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
+      controls.handleResize();
+      controls.update();
      renderer.render(scene, camera);
    };
  },
};
</code></pre>
<p>オブジェクトをドラッグすると回転するようになりました。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-multiple-scenes-controls.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-multiple-scenes-controls.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>これらのテクニックはこのサイト自体にも使われています。
特に<a href="threejs-primitives.html">プリミティブの記事</a>と<a href="threejs-materials.html">マテリアルの記事</a>では、このテクニックを使ってページ全体に様々なサンプルを追加しています。</p>
<p>もう1つの解決策はオフスクリーンのキャンバスにレンダリングし、各要素で結果を2Dキャンバスにコピーする事です。
この解決策の利点は、分離した各領域を合成する方法に制限がないです。
以前の解決策では、背景に単一のキャンバスを使用していました。
この解決策では通常のHTML要素を使用しています。</p>
<p>欠点は、領域ごとにコピーが発生するため遅いという事です。
どのくらい遅くなるかはブラウザとGPUに依存します。</p>
<p>必要な変更は非常に小さいです。</p>
<p>まず、ページ内にキャンバスが不要になったのでHTMLを変更します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
-  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
  ...
&lt;/body&gt;
</code></pre>
<p>CSSも変更します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">-#c {
-  position: absolute;
-  left: 0;
-  top: 0;
-  width: 100%;
-  height: 100%;
-  display: block;
-  z-index: -1;
-}
canvas {
  width: 100%;
  height: 100%;
  display: block;
}
*[data-diagram] {
  display: inline-block;
  width: 5em;
  height: 3em;
}
</code></pre><p>全てのキャンバスは作成し、コンテナとなる変数に格納する形にします。</p>
<p>では、JavaScriptを変更してみましょう。
もはやキャンバスを探す事は不要になりました。
代わりに私たちは1つのキャンバスを作ります。
また、最初にシザーテストをONにします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
-  const canvas = document.querySelector(&#39;#c&#39;);
+  const canvas = document.createElement(&#39;canvas&#39;);
  const renderer = new THREE.WebGLRenderer({canvas, alpha: true});
+  renderer.setScissorTest(true);

  ...
</code></pre>
<p>次に各シーンに対して2Dレンダリングのコンテキストを作成し、そのシーンの要素にキャンバスを追加します。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sceneElements = [];
function addScene(elem, fn) {
+  const ctx = document.createElement(&#39;canvas&#39;).getContext(&#39;2d&#39;);
+  elem.appendChild(ctx.canvas);
-  sceneElements.push({elem, fn});
+  sceneElements.push({elem, ctx, fn});
}
</code></pre>
<p>レンダリング時に、レンダラーのキャンバスがレンダリングするのに十分な大きさでない場合はサイズを大きくします。
また、キャンバスのサイズが間違っている場合はそのサイズを変更します。
最後にシザーとビューポートを設定し、シーンをレンダリングしその結果をキャンバスにコピーします。</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;

-  resizeRendererToDisplaySize(renderer);
-
-  renderer.setScissorTest(false);
-  renderer.setClearColor(clearColor, 0);
-  renderer.clear(true, true);
-  renderer.setScissorTest(true);
-
-  const transform = `translateY(${window.scrollY}px)`;
-  renderer.domElement.style.transform = transform;

-  for (const {elem, fn} of sceneElements) {
+  for (const {elem, fn, ctx} of sceneElements) {
    // get the viewport relative position of this element
    const rect = elem.getBoundingClientRect();
    const {left, right, top, bottom, width, height} = rect;
+    const rendererCanvas = renderer.domElement;

    const isOffscreen =
        bottom &lt; 0 ||
-        top &gt; renderer.domElement.clientHeight ||
+        top &gt; window.innerHeight ||
        right &lt; 0 ||
-        left &gt; renderer.domElement.clientWidth;
+        left &gt; window.innerWidth;

    if (!isOffscreen) {
-      const positiveYUpBottom = renderer.domElement.clientHeight - bottom;
-      renderer.setScissor(left, positiveYUpBottom, width, height);
-      renderer.setViewport(left, positiveYUpBottom, width, height);

+      // make sure the renderer&#39;s canvas is big enough
+      if (rendererCanvas.width &lt; width || rendererCanvas.height &lt; height) {
+        renderer.setSize(width, height, false);
+      }
+
+      // make sure the canvas for this area is the same size as the area
+      if (ctx.canvas.width !== width || ctx.canvas.height !== height) {
+        ctx.canvas.width = width;
+        ctx.canvas.height = height;
+      }
+
+      renderer.setScissor(0, 0, width, height);
+      renderer.setViewport(0, 0, width, height);

      fn(time, rect);

+      // copy the rendered scene to this element&#39;s canvas
+      ctx.globalCompositeOperation = &#39;copy&#39;;
+      ctx.drawImage(
+          rendererCanvas,
+          0, rendererCanvas.height - height, width, height,  // src rect
+          0, 0, width, height);                              // dst rect
    }
  }

  requestAnimationFrame(render);
}
</code></pre>
<p>結果は同じように見えます。</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-multiple-scenes-copy-canvas.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-multiple-scenes-copy-canvas.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

</p>
<p>この解決策のもう1つの利点は、Web workerでレンダリングするために<a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas"><code class="notranslate" translate="no">OffscreenCanvas</code></a>のテクニックも使用しています。
残念ながら2020年7月現在、<code class="notranslate" translate="no">OffscreenCanvas</code> はChromeのみの対応となっています。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-multiple-scenes.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-multiple-scenes.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-multiple-scenes.html" selected>日本語</a>
    <option value="/threejs/lessons/kr/threejs-multiple-scenes.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-multiple-scenes.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-multiple-scenes.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-fundamentals.html">基礎知識</a></li>
<li><a href="/threejs/lessons/ja/threejs-responsive.html">レスポンシブデザイン</a></li>
<li><a href="/threejs/lessons/ja/threejs-prerequisites.html">前提条件</a></li>
<li><a href="/threejs/lessons/ja/threejs-setup.html">セットアップ</a></li>
        </ul>
  <li>基礎</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-primitives.html">プリミティブ</a></li>
<li><a href="/threejs/lessons/ja/threejs-scenegraph.html">シーングラフ</a></li>
<li><a href="/threejs/lessons/ja/threejs-materials.html">マテリアル</a></li>
<li><a href="/threejs/lessons/ja/threejs-textures.html">テクスチャ</a></li>
<li><a href="/threejs/lessons/ja/threejs-lights.html">ライト</a></li>
<li><a href="/threejs/lessons/ja/threejs-cameras.html">カメラ</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadows.html">Shadows</a></li>
<li><a href="/threejs/lessons/ja/threejs-fog.html">Fog</a></li>
<li><a href="/threejs/lessons/ja/threejs-rendertargets.html">Render Targets</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-geometry.html">Custom Geometry</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-buffergeometry.html">Custom BufferGeometry</a></li>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-rendering-on-demand.html">要求されたレンダリング</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-javascript.html">JavaScriptのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-glsl.html">GLSLのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#screenshot">スクリーンショットを撮る</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#preservedrawingbuffer">キャンバスがクリアされるのを防ぐ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#tabindex">キャンバスからキーボード入力を取得する</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#transparent-canvas">キャンバスを透明にする</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#html-background">HTMLの背景にthree.jsを使う</a></li>
        </ul>
  <li>最適化</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects.html">多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html">アニメーションする多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-offscreencanvas.html">Web WorkerでOffscreenCanvasを使用する</a></li>
        </ul>
  <li>解決策</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-load-obj.html">OBJファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-load-gltf.html">GLTFファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-backgrounds.html">背景やスカイボックスを追加する</a></li>
<li><a href="/threejs/lessons/ja/threejs-transparency.html">透明なオブジェクトの描画方法</a></li>
<li><a href="/threejs/lessons/ja/threejs-multiple-scenes.html">複数キャンバスと複数シーン</a></li>
<li><a href="/threejs/lessons/ja/threejs-picking.html">マウスでオブジェクトをピッキング</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing.html">ポストプロセス</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing-3dlut.html">エフェクトにLUTファイルを適用する</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ja/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ja/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ja/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ja/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ja/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ja/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ja/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>参照</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-material-table.html">Material Table</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.jsドキュメント</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>質問はありますか? <a href="http://stackoverflow.com/questions/tagged/three.js">何かあればstackoverflowで尋ねて下さい</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/threefundamentals/issues">またはgithubでissueを作って下さい</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.jsの複数キャンバスと複数シーン';
            var disqus_title = 'Three.jsの複数キャンバスと複数シーン';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "threejsfundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



